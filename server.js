
import dotenv from 'dotenv';
import express from 'express';
import Stripe from 'stripe';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import { questionMutatorService } from './services/QuestionMutatorService.ts';
import { hybridQuestionService } from './services/HybridQuestionService.ts';
import { debugRouter } from './routes/debug.ts';

dotenv.config();

const app = express();
// Safely handle missing key for local dev startup (will fail on request if missing)
const stripe = process.env.STRIPE_SECRET_KEY ? new Stripe(process.env.STRIPE_SECRET_KEY) : null;

// Middleware
app.use(cors({
  origin: ['http://localhost:5173', 'http://localhost:3000', 'https://psn-project.vercel.app'],
  credentials: true
}));

// Note: Stripe Webhook requires raw body parsing, not JSON
app.post('/api/stripe-webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

  if (!endpointSecret || !stripe) {
    return res.status(400).send(`Webhook Error: Webhook secret or Stripe key missing.`);
  }

  let event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Handle the event
  if (event.type === 'checkout.session.completed') {
    const session = event.data.object;

    // In a real application, we would use Firebase Admin SDK to securely
    // update the user's document in Firestore with `isPremium: true` 
    // or `hasExamAccess: true` depending on session.metadata.product
    console.log(`[Webhook] Payment successful for User ID: ${session.metadata.userId}`);
    console.log(`[Webhook] Granted access for product: ${session.metadata.product}`);
  }

  res.send();
});

// JSON parser for all other routes
app.use(express.json());

// Rate Limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 20, // Limit each IP to 20 requests per `window`
  message: { error: 'Too many requests from this IP, please try again after 15 minutes' },
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api/', apiLimiter);

// Routes
app.post('/api/create-checkout-session', async (req, res) => {
  if (!stripe) {
    return res.status(500).json({ error: "Server Misconfiguration: Stripe Secret Key missing." });
  }

  const { userId, email, returnUrl, type, plan } = req.body;

  if (!userId || !returnUrl || !type) {
    return res.status(400).json({ error: "Missing required parameters." });
  }

  // Basic open redirect prevention
  try {
    const parsedReturnUrl = new URL(returnUrl);
    // Allow localhost or standard prod domain, or generic fail safe
    // If not a valid host, it throws an error.
  } catch (e) {
    return res.status(400).json({ error: "Invalid return URL." });
  }

  // SECURITY ENFORCEMENT: Fixed Pricing Logic
  // No client-side price manipulation allowed.
  let productName = 'Professional Certification Exam';
  let amount = 5000; // STRICT $50.00
  let description = 'One-time access. Non-refundable.';

  if (type === 'subscription') {
    productName = 'DevOffs Verified Membership';
    if (plan === 'yearly') {
      amount = 30000; // $300.00
      description = 'Yearly Verified Membership';
    } else {
      amount = 2900; // $29.00
      description = 'Monthly Verified Membership';
    }
  }

  try {
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [
        {
          price_data: {
            currency: 'usd',
            product_data: {
              name: productName,
              description: description,
              images: ['https://cdn-icons-png.flaticon.com/512/2921/2921222.png'],
            },
            unit_amount: amount,
          },
          quantity: 1,
        },
      ],
      mode: 'payment',
      success_url: `${returnUrl}?payment_success=true&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${returnUrl}?payment_canceled=true`,
      metadata: {
        userId,
        product: type,
        security_token: `SECURE_${Date.now()}_${userId}` // Traceability
      },
      customer_email: email,
    });

    res.json({ url: session.url });
  } catch (e) {
    console.error("Stripe Error:", e.message);
    res.status(500).json({ error: e.message });
  }
});

app.get('/api/questions/mutate', async (req, res) => {
  try {
    const { problemId, theme } = req.query;

    // Support picking a random problem if none is specified
    const targetId = problemId || 'p1_two_sum';

    // Execute Mutator Service
    const mutatedQuestion = await questionMutatorService.mutateProblem(
      targetId,
      theme
    );

    // Provide the generated question, or fallback silently generated by the service
    return res.status(200).json(mutatedQuestion);
  } catch (error) {
    console.error("Mutation Route Error:", error);
    return res.status(500).json({ error: "Failed to mutate question." });
  }
});

// Diagnostics Route
app.use('/api/debug', debugRouter);

// Hybrid Question Route
app.get('/api/question/random', async (req, res) => {
  try {
    const questionData = await hybridQuestionService.fetchAndMutateRandomProblem();
    res.json(questionData);
  } catch (error) {
    console.error('Error fetching hybrid question:', error);
    res.status(500).json({ error: 'Failed to generate hybrid question' });
  }
});

// Start Server
const PORT = process.env.PORT || 3000;
app.listen(PORT, '0.0.0.0', () => console.log(`Node server listening on port ${PORT}!`));
